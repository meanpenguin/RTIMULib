////////////////////////////////////////////////////////////////////////////
//
//  This file is part of RTIMULib
//
//  Copyright (c) 2014-2015, richards-tech, LLC
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
//  Software, and to permit persons to whom the Software is furnished to do so,
//  subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
//  PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


#include "RTIMULib.h"

#define __STDC_FORMAT_MACROS
#include <inttypes.h>

#include <termios.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/wait.h>
#include <sys/ioctl.h>

char   getUserChar();

static RTIMUSettings *settings;
static RTPressure    *pressure; 
static RTHumidity    *humidity;

int main()
{
    int pressureSampleCount = 0;
    int humiditySampleCount = 0;
    int pressureSampleRate = 0;
    int humiditySampleRate = 0;
    uint64_t rateTimer;
    uint64_t now;
    uint64_t lastPoll;
    uint64_t lastPressurePoll;
    uint64_t lastHumidityPoll;
    uint64_t lastDisplayPoll;
    uint64_t lastUserPoll;
    
	int pressurePollInterval = 1;
	int humidityPollInterval = 1;

    bool displayData = true;
    
    float humidity_avg = 0.0f;
    float pressure_avg = 0.0f;
    char input;
    bool mustExit = false;
    
    HUMIDITY_DATA humidityData;
    PRESSURE_DATA pressureData;

    pressureData.pressureValid = false;
    pressureData.pressure = -9999.9999;
    pressureData.temperatureValid = false;
    pressureData.temperature = -9999.9999;

    humidityData.humidityValid = false;
    humidityData.humidity = -9999.9999;
    humidityData.temperatureValid = false;
    humidityData.temperature = -9999.9999;

    //  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.

    settings = new RTIMUSettings("RTIMULib");

    //  set up pressure sensor

    printf("Creating Pressure\n");
    pressure = RTPressure::createPressure(settings);

    RTFLOAT staticPressure = 1013.25f;

    if (pressure != NULL) {
        pressure->pressureInit();
        pressurePollInterval = pressure->pressureGetPollInterval() * 1000;
    }

    //  set up humidity sensor

    printf("Creating Humidity\n");
    humidity = RTHumidity::createHumidity(settings);

    if (humidity != NULL) {
        humidity->humidityInit();
        humidityPollInterval = humidity->humidityGetPollInterval() * 1000;
    }
    
    //  set up console io

    struct termios    ctty;
    tcgetattr(fileno(stdout), &ctty);
    ctty.c_lflag &= ~(ICANON);
    tcsetattr(fileno(stdout), TCSANOW, &ctty);

    // dry run of the system to stabilize

    int i=0;
    lastPoll = RTMath::currentUSecsSinceEpoch();
    while (i < 80) {

        now = RTMath::currentUSecsSinceEpoch();
        int pollDelay = (10000 - (int)(now - lastPoll));
        if (pollDelay > 0) { usleep(pollDelay); }
        lastPoll = now;

        if (humidity != NULL) { humidity->humidityRead(); }
        if (pressure != NULL) { pressure->pressureRead(); }
        i++; 
    }

    if (pressure != NULL) { 
       pressureData = pressure->getPressureData();
       if (pressureData.pressureValid) {staticPressure = pressureData.pressure;}
    }

    //  set up timers

    rateTimer = lastDisplayPoll = lastPoll = lastHumidityPoll = lastPressurePoll = lastUserPoll = RTMath::currentUSecsSinceEpoch();
    
    //  now just process data
    while (!mustExit) {
   
        //  run this loop no faster than 1000Hz
        now = RTMath::currentUSecsSinceEpoch();
        int pollDelay = (1000 - (int)(now - lastPoll));
        if (pollDelay > 0) { usleep(pollDelay); }
        lastPoll = now;

        //  read pressure data 
        if (pressure != NULL) {
          now = RTMath::currentUSecsSinceEpoch();
          if ( (int)(now - lastPressurePoll) >= pressurePollInterval ) {
            // pressure read requires multiple calls in most sensors: 
            //   First call initiates conversion, 
            //   Second call reads temperature, and initiates pressure conversion
            //   Third call reads pressure and then calibrates the reading
            lastPressurePoll = now;
            if (pressure->pressureRead()){
                pressureData=pressure->getPressureData();
                if (pressureData.pressureValid) {
                  pressure_avg = pressure->updateAveragePressure(pressureData.pressure); // smooth it out
                }
	            pressureSampleCount++;
            };
          }
        }
        
        //  read the humidity data
        if (humidity != NULL) {
          now = RTMath::currentUSecsSinceEpoch();
          if ( (int)(now - lastHumidityPoll) >= humidityPollInterval ) {
            lastHumidityPoll = now;
            if (humidity->humidityRead()) {
                humidityData = humidity->getHumidityData();
                if (humidityData.humidityValid) {
                  humidity_avg = humidity->updateAverageHumidity(humidityData.humidity); // smooth it out
                }
	            humiditySampleCount++;
            }
          }
        }
		
		if ((now - rateTimer) > 1000000) {
			pressureSampleRate = pressureSampleCount;
			humiditySampleRate = humiditySampleCount;
			pressureSampleCount = 0;
			humiditySampleCount = 0;
			rateTimer = now;
		}


        //  display 10 times per second
        now = RTMath::currentUSecsSinceEpoch();
        if ((now - lastDisplayPoll) > 100000) {
            lastDisplayPoll = now;
            if (displayData) {
                printf("\e[1;1H\e[2J");  // clear screen and move cursor 1/1

                printf("Sample Rate: P:%d H:%d\n", pressureSampleRate, humiditySampleRate);

                if (pressure != NULL) {
                    printf("Pressure: %4.2f, avg: %4.2f\nHeight above sea level: %4.1f, Depth below sea level: %4.3f\n",
                           pressureData.pressure, pressure_avg,
						                          RTMath::convertPressureToHeight(pressure_avg, staticPressure),
                                                  RTMath::convertPressureToDepth(pressure_avg, staticPressure));
                }
                if (humidity != NULL) {
                    printf("Humidity: %4.1f%% avg: %4.1f%%\n",
                           humidityData.humidity, humidity_avg);
                }

                printf("Temperature: ");
                if (pressure != NULL) { printf("Pressure Sensor %4.2f, ", pressureData.temperature); }
                if (humidity != NULL) { printf("Humidity Sensor %4.2f", humidityData.temperature); }
                printf("\n");

                printf("---\n p set static pressure\n s/S: stream on/off\n x: exit\n");

                fflush(stdout);
            } // display data
        }

        now = RTMath::currentUSecsSinceEpoch();
        if ( (now - lastUserPoll) > 500000 ) { // 20Hz
            lastUserPoll = now;
            if ((input = getUserChar()) != 0) {
                switch (input) {
                    case 'p' :
                        staticPressure = pressureData.pressure;
                        break;
                    case 's' :
                        // trun streaming off
                        displayData = false;
                        break;
                    case 'S' :
                        // trun streaming on
                        displayData = true;
                        break;
                    case 'x' :
                        // must exit
                        mustExit = true;
                        break;
                    } // end switch input
            } // end if user pressed key
        } // user poll
    } // while
    printf("\nRTIMULibDrive11 exiting\n");
    settings->saveSettings(); // should update gyro bias
    return 0;
}

char getUserChar()
{
    int i;
    ioctl(0, FIONREAD, &i);
    if (i <= 0)
        return 0;
    // return tolower(getchar());
    return getchar();
}
